\paragraph{}
It would be easy to find a dynamic algorithm running in $O(n^3)$ with the following approach: finding the best parenthesization is finding the index $i$ such that the we can get the maximum from the parenthesization of the first terms $x_1,...,x_i$ and the minimum from the parenthesization of the terms $x_{i+1},...,x_n$.
\newline
Therefore, we only need to have two matrices to compute and store the maximum (minimum respectively) that we can get from the parenthesization of the sequence of terms $x_i,...,x_j$, and the associated parenthesizations.
\newline
We can start by initialising those two matrices for sequences of length 1 and 2 (for which we have no choice of parenthesization), and then filling out the other entries of the matrices by increasing length of sequence.
\newline
Then the running time is $O(n^3)$ because we have two matrices of size $n^2$ to fill, and that for each entry of these matrices, we need to find the best solution among at most $n$ possible solutions (we use a very loose bound here...).
\newline
However, one of us has come with another approach...
\paragraph{}
We first want to realize that for any parenthesization. We can write the following : 

\[parenthesization(x_1/x_2/.../x_n) = \prod x_i^{d_i}\]

\paragraph{}
Where $d_i = \pm 1$. For any parenthesization we always have $d_1 = 1$ and $d_2 = -1$. For the remaining $d_i$ the optimum would be to have $d_i = 1$ when $x_i > 1$ and $d_i = -1$ when $x_i < 1$. We can obtain this result with a simple parenthesization. 

\paragraph{}
When not using parenthesis the divisions are computed from the left to the right. For example the following parenthesization gives us : 

\[x_1/x_2/...(x_a/.../x_b)/.../x_n = \prod x_i^{d_i}\]

\paragraph{}
with $d_a = -1$ and $d_{a+1} = ... = d_b = 1$. All other $d_i$ but $d_1$ is $-1$. With this in head we can easily include inside parenthesis all the $x_i$ bigger than 1. For any consecutive list of elements $x_a,...,x_{b+1}$ where $x_a < 1$, $x_{a+1}>1,...,x_b>1$ and $x_{b+1}<1$ we just want to include inside parenthesis the elements from $x_a$ to $x_b$. This gives us the optimal solution describe above and implies an easy linear time algorithm.




